{
    "id": 1,
    "jsonrpc": "2.0",
    "method": "CreateTransaction",
    "params": [
        {
            "version": 65537,
            "toAddr": "0x0000000000000000000000000000000000000000",
            "nonce": 1,
            "pubKey": "0395c4f9af6f329567d84bcf57f64fe35f4f8d6621861d39bedba029a903fdc56a",
            "amount": "0",
            "gasPrice": "1000000000",
            "gasLimit": "25000",
            "code": "scilla_version 0\n\nimport ListUtils IntUtils BoolUtils\n\n\nlibrary WalletLib\n\nlet mk_contract_initialized_event =\n  { _eventname : \"Contract initialized\" }\n\n(* Event for communicating a new transaction id *)\nlet mk_transaction_added_event =\n  fun (tc : Uint32) =>\n    { _eventname : \"Transaction created\" ;\n     transactionId : tc }\n\n(* Event for communicating that a transaction was signed *)\nlet mk_signed_transaction_event =\n  fun (tc : Uint32) =>\n    { _eventname : \"Transaction signed\"; transactionId : tc }\n\n(* Event for communicating that a signature was revoked *)\nlet mk_signature_revoked_event =\n  fun (tc : Uint32) =>\n    { _eventname : \"Signature revoked\"; transactionId : tc }\n\ntype Error =\n| NonOwnerCannotSign\n| UnknownTransactionId\n| InsufficientFunds\n| NoSignatureListFound\n| AlreadySigned\n| NotAlreadySigned\n| InvalidAmount\n| NotEnoughSignatures\n| SenderMayNotExecute\n| NonOwnerCannotSubmit\n| IncorrectSignatureCount\n\n(* Error events *)\nlet mk_error_event =\n  fun (err : Error) =>\n  let err_code =\n    match err with\n    | NonOwnerCannotSign        => Int32 -1\n    | UnknownTransactionId      => Int32 -2\n    | InsufficientFunds         => Int32 -3\n    | NoSignatureListFound      => Int32 -4\n    | AlreadySigned             => Int32 -5\n    | NotAlreadySigned          => Int32 -6\n    | InvalidAmount             => Int32 -7\n    | NotEnoughSignatures       => Int32 -8\n    | SenderMayNotExecute       => Int32 -9\n    | NonOwnerCannotSubmit      => Int32 -10\n    | IncorrectSignatureCount   => Int32 -11\n    end in\n  { _eventname : \"WalletError\" ; err_code : err_code }\n\nlet t = True\nlet f = False\nlet zero = Uint32 0\nlet zeroUint128 = Uint128 0\nlet one = Uint32 1\nlet transaction_inc = one\n\n(* Type of Proxy transactions. *)\n(* All calls are made to the proxy contract *)\ntype ProxyTransaction =\n(* upgradeTo (newImplementation : ByStr20) *)\n| UpgradeTo of ByStr20\n(* pause () *)\n| Pause\n(* unpause () *)\n| Unpause\n(* changeProxyAdmin(newAdmin : ByStr20) *)\n| ChangeProxyAdmin of ByStr20\n(* drainProxyContractBalance() *)\n| DrainProxyContractBalance\n(* update_admin(admin : ByStr20)  *)\n| UpdateAdmin of ByStr20\n(* update_verifier (verif : ByStr20)  *)\n| UpdateVerifier of ByStr20\n(* drain_contract_balance ()  *)\n| DrainContractBalance\n(* add_ssn (ssnaddr : ByStr20, urlraw : String, urlapi : String) *)\n| AddSsn of ByStr20 String String\n(* add_ssn_after_upgrade (ssnaddr : ByStr20, stake_amount : Uint128, rewards : Uint128, urlraw : String, urlapi : String, buffered_deposit : Uint128) *)\n| AddSsnAfterUpgrade of ByStr20 Uint128 Uint128 String String Uint128\n(* update_staking_parameter (min_stake : Uint128, max_stake : Uint128, contract_max_stake : Uint128) *)\n| UpdateContractStakeParameter of Uint128 Uint128 Uint128\n(*remove_ssn (ssnaddr : ByStr20) *)\n| RemoveSsn of ByStr20 \n\n(* Type of (outstanding) transactions *)\ntype Transaction =\n(* Transfer of native tokens *)\n| NativeTransaction of ByStr20 Uint128 String\n(* Custom token transactions *)\n| CustomTransaction of ByStr20 ProxyTransaction\n\n(* Make map of owners *)\nlet mk_owners_map =\n  fun (owners : List ByStr20) =>\n    let init = Emp ByStr20 Bool in\n    let iter =\n      fun (acc : Map ByStr20 Bool) =>\n      fun (cur_owner : ByStr20) =>\n        (* Add owner unconditionally. We check for duplicates later *)\n        builtin put acc cur_owner t\n        in\n    let folder = @list_foldl ByStr20 (Map ByStr20 Bool) in\n    folder iter init owners\n\n(* Wrap single message into singleton list *)\nlet one_msg =\n  fun (msg : Message) =>\n    let nil_msg = Nil {Message} in\n    Cons {Message} msg nil_msg\n\n(* Create native transaction message as singleton list *)\nlet native_transaction_msg_as_list =\n  fun (recipient : ByStr20) =>\n  fun (amount : Uint128) =>\n  fun (tag : String) =>\n    let msg = {_tag : tag; _recipient : recipient; _amount : amount } in\n    one_msg msg\n\n(* Create custom transaction message as singleton list *)\nlet custom_transaction_msg_as_list =\n  fun (proxyContract : ByStr20) =>\n  fun (proxyTransaction : ProxyTransaction) =>\n    let msg =\n      match proxyTransaction with\n      | UpgradeTo newImplementation =>\n        (* UpgradeTo (newImplementation : ByStr20) *)\n        {_recipient : proxyContract ;\n         _tag : \"upgradeTo\" ;\n         _amount : zeroUint128 ;\n         newImplementation : newImplementation }\n      | Pause =>\n        (* pause()  *)\n        {_recipient : proxyContract ;\n        _tag : \"pause\" ;\n        _amount : zeroUint128 }\n      | Unpause =>\n        (* unpause()  *)\n        {_recipient : proxyContract ;\n        _tag : \"unpause\" ;\n        _amount : zeroUint128 }   \n      | ChangeProxyAdmin newAdmin =>\n        (* changeProxyAdmin(newAdmin : ByStr20)  *)\n        {_recipient : proxyContract ;\n         _tag : \"changeProxyAdmin\" ;\n         _amount : zeroUint128 ;\n         newAdmin : newAdmin }\n      | DrainProxyContractBalance =>\n        (* drainProxyContractBalance()  *)\n        {_recipient : proxyContract ;\n         _tag : \"drainProxyContractBalance\" ;\n         _amount : zeroUint128}\n      | UpdateAdmin admin =>\n        (* update_admin(admin : ByStr20)  *)\n        {_recipient : proxyContract;\n         _tag : \"update_admin\" ;\n         _amount : zeroUint128 ;\n         admin : admin}\n      | UpdateVerifier verif =>\n        (* update_verifier(verif : ByStr20)  *)\n        {_recipient : proxyContract ;\n         _tag : \"update_verifier\" ;\n         _amount : zeroUint128 ;\n         verif : verif}\n      | DrainContractBalance  =>\n        (* drain_contract_balance()  *)\n        {_recipient : proxyContract ;\n         _tag : \"drain_contract_balance\" ;\n         _amount : zeroUint128}\n      | UpdateContractStakeParameter min_stake max_stake contract_max_stake =>\n        (* update_staking_parameter(min_stake : Uint128, max_stake : Uint128, contract_max_stake : Uint128) *)\n        {_recipient : proxyContract ;\n         _tag : \"update_staking_parameter\" ;\n         _amount : zeroUint128 ;\n         min_stake : min_stake;\n         max_stake : max_stake;\n         contract_max_stake : contract_max_stake}\n      | AddSsn ssnaddr urlraw urlapi =>\n        (* add_ssn(ssnaddr : ByStr20, urlraw : String, urlapi : String) *)\n        {_recipient : proxyContract ;\n         _tag : \"add_ssn\" ;\n         _amount : zeroUint128 ;\n         ssnaddr : ssnaddr;\n         urlraw : urlraw;\n         urlapi : urlapi}\n      | AddSsnAfterUpgrade ssnaddr stake_amount rewards urlraw urlapi buffered_deposit =>\n        (* add_ssn_after_upgrade(ssnaddr : ByStr20, stake_amount : Uint128, rewards : Uint128, urlraw : String, urlapi : String, buffered_deposit : Uint128) *)\n        {_recipient : proxyContract ;\n         _tag : \"add_ssn_after_upgrade\" ;\n         _amount : zeroUint128 ;\n         ssnaddr : ssnaddr;\n         stake_amount : stake_amount;\n         rewards : rewards;\n         urlraw : urlraw;\n         urlapi : urlapi;\n         buffered_deposit : buffered_deposit}\n      | RemoveSsn ssnaddr =>\n        (* remove_ssn(ssnaddr : ByStr20) *)\n        {_recipient : proxyContract ;\n         _tag : \"remove_ssn\" ;\n         _amount : zeroUint128 ;\n         ssnaddr : ssnaddr}   \n      end\n    in\n    one_msg msg\n\ncontract Wallet\n(\nowners_list         : List ByStr20,\nrequired_signatures : Uint32\n)\nwith\n  let len = @list_length ByStr20 in\n  let no_of_owners = len owners_list in\n  let owners_ok = builtin lt zero no_of_owners in\n  let required_sigs_not_too_low = builtin lt zero required_signatures in\n  let required_sigs_too_high = builtin lt no_of_owners required_signatures in\n  let required_sigs_not_too_high = negb required_sigs_too_high in\n  let required_sigs_ok = andb required_sigs_not_too_high required_sigs_not_too_low in\n  let all_ok = andb required_sigs_ok owners_ok in\n  (* Building the owners map is expensive, so avoid checking the owners map until *)\n  (* everything else has been checked *)\n  match all_ok with\n  | True =>\n    let owners_map = mk_owners_map owners_list in\n    let size_of_owners_map = builtin size owners_map in\n    builtin eq size_of_owners_map no_of_owners\n  | False =>\n    False\n  end\n=>\n\n(* adr -> True indicates an owner *)\n(* adr not in map indicates non-owner *)\n(* adr -> False is not used *)\nfield owners           : Map ByStr20 Bool = mk_owners_map owners_list\n\nfield transactionCount : Uint32 = Uint32 0\n\n(* Collected signatures for transactions *)\nfield signatures       : Map Uint32 (Map ByStr20 Bool) =\n  Emp Uint32 (Map ByStr20 Bool)\n\n(* Running count of collected signatures for transactions *)\nfield signature_counts : Map Uint32 Uint32 =\n  Emp Uint32 Uint32\n\n(* Transactions *)\nfield transactions     : Map Uint32 Transaction =\n                           Emp Uint32 Transaction\n\nprocedure MakeError (err : Error)\n  e = mk_error_event err;\n  event e\nend\n\n(* Add signature to signature list *)\nprocedure AddSignature (transactionId : Uint32, signee : ByStr20)\n  sig <- exists signatures[transactionId][signee];\n  match sig with\n  | False =>\n    count <- signature_counts[transactionId];\n    match count with\n    | None =>\n      (* 0 signatures *)\n      signature_counts[transactionId] := one\n    | Some c =>\n      new_c = builtin add c one;\n      signature_counts[transactionId] := new_c\n    end;\n    signatures[transactionId][signee] := t;\n    e = mk_signed_transaction_event transactionId;\n    event e\n  | True =>\n    (* Already signed *)\n    err = AlreadySigned;\n    MakeError err\n  end\nend\n\n(* Common procedure for all new transactions. *)\n(* Check that the sender is owner. Store and sign the transaction. *)\nprocedure SubmitTransaction (transaction : Transaction)\n  sender_is_owner <- exists owners[_sender];\n  match sender_is_owner with\n  | False =>\n    err = NonOwnerCannotSubmit;\n    MakeError err\n  | True =>\n    tc <- transactionCount;\n    transactions[tc] := transaction;\n    (* Sender implicitly signs *)\n    AddSignature tc _sender;\n    (* Increment transaction counter *)\n    tc_new = builtin add tc transaction_inc;\n    (* Update transaction count *)\n    transactionCount := tc_new;\n    (* Create event with transaction Id *)\n    e = mk_transaction_added_event tc;\n    event e\n  end\nend\n\n(* Submit a transaction of native tokens for future signoff *)\ntransition SubmitNativeTransaction (recipient : ByStr20, amount : Uint128, tag : String)\n  amount_is_zero = builtin eq amount zeroUint128;\n  match amount_is_zero with\n  | True =>\n    (* Illegal transaction *)\n    err = InvalidAmount;\n    MakeError err\n  | False =>\n    transaction = NativeTransaction recipient amount tag;\n    SubmitTransaction transaction\n  end\nend\n\n(* Common submit procedure for custom transactions *)\nprocedure SubmitCustomTransaction (proxyContract : ByStr20, proxyTransaction : ProxyTransaction)\n  transaction = CustomTransaction proxyContract proxyTransaction;\n  SubmitTransaction transaction\nend\n\n(* Submit a new UpgradeTo transaction for future signoff *)\ntransition SubmitCustomUpgradeToTransaction (proxyContract : ByStr20, newImplementation : ByStr20)\n  transaction = UpgradeTo newImplementation;\n  SubmitCustomTransaction proxyContract transaction\nend\n\n(* Submit a new pause transaction for future signoff *)\ntransition SubmitCustomPauseTransaction (proxyContract : ByStr20)\n  transaction = Pause;\n  SubmitCustomTransaction proxyContract transaction\nend\n\n(* Submit a new unpause transaction for future signoff *)\ntransition SubmitCustomUnpauseTransaction (proxyContract : ByStr20)\n  transaction = Unpause;\n  SubmitCustomTransaction proxyContract transaction\nend\n\n(* Submit a new ChangeProxyAdmin transaction for future signoff *)\ntransition SubmitCustomChangeProxyAdminTransaction (proxyContract : ByStr20, newAdmin : ByStr20)\n  transaction = ChangeProxyAdmin newAdmin;\n  SubmitCustomTransaction proxyContract transaction\nend\n\ntransition SubmitCustomDrainProxyContractBalance (proxyContract : ByStr20)\n  transaction = DrainProxyContractBalance;\n  SubmitCustomTransaction proxyContract transaction\nend\n\n(* Submit a new UpdateAdmin transaction for future signoff *)\ntransition SubmitCustomUpdateAdminTransaction (proxyContract : ByStr20, admin : ByStr20)\n  transaction = UpdateAdmin admin;\n  SubmitCustomTransaction proxyContract transaction\nend\n\n(* Submit a new UpdateVerifier transaction for future signoff *)\ntransition SubmitCustomUpdateVerifierTransaction (proxyContract : ByStr20, verif : ByStr20)\n  transaction = UpdateVerifier verif;\n  SubmitCustomTransaction proxyContract transaction\nend\n\n(* Submit a new DrainContractBalance transaction for future signoff *)\ntransition SubmitCustomDrainContractBalanceTransaction (proxyContract : ByStr20)\n  transaction = DrainContractBalance;\n  SubmitCustomTransaction proxyContract transaction\nend\n\n\n(* Submit a new ContractMaxStake transaction for future signoff *)\ntransition SubmitCustomUpdateStakingParameterTransaction (proxyContract : ByStr20, min_stake : Uint128, max_stake : Uint128, contract_max_stake : Uint128)\n  transaction = UpdateContractStakeParameter min_stake max_stake contract_max_stake;\n  SubmitCustomTransaction proxyContract transaction\nend\n\n(* Submit a new AddSsn transaction for future signoff *)\ntransition SubmitCustomAddSsnTransaction (proxyContract : ByStr20, ssnaddr : ByStr20, urlraw : String, urlapi : String)\n  transaction = AddSsn ssnaddr urlraw urlapi;\n  SubmitCustomTransaction proxyContract transaction\nend\n\n(* For contract upgrade purpose *)\ntransition SubmitCustomAddSsnAfterUpgradeTransaction (proxyContract : ByStr20, ssnaddr : ByStr20, stake_amount : Uint128, rewards : Uint128, urlraw : String, urlapi : String, buffered_deposit : Uint128)\n  transaction = AddSsnAfterUpgrade ssnaddr stake_amount rewards urlraw urlapi buffered_deposit;\n  SubmitCustomTransaction proxyContract transaction\nend\n\n(* Submit a new RemoveSsn transaction for future signoff *)\ntransition SubmitCustomRemoveSsnTransaction (proxyContract : ByStr20, ssnaddr : ByStr20)\n  transaction = RemoveSsn ssnaddr;\n  SubmitCustomTransaction proxyContract transaction\nend\n(* Sign off on an existing transaction *)\ntransition SignTransaction (transactionId : Uint32)\n  (* Only owners are allowed to sign off transactions *)\n  sender_is_owner <- exists owners[_sender];\n  match sender_is_owner with\n  | False =>\n    err = NonOwnerCannotSign;\n    MakeError err\n  | True =>\n    (* Transaction must have been submitted *)\n    transaction <- transactions[transactionId];\n    match transaction with\n    | None =>\n      err = UnknownTransactionId;\n      MakeError err\n    | Some _ =>\n      (* Remaining error cases handled by AddSignature *)\n      AddSignature transactionId _sender\n    end\n  end\nend\n\n(* Revoke signature of existing transaction, if it has not yet been executed. *)\ntransition RevokeSignature (transactionId : Uint32)\n  sig <- exists signatures[transactionId][_sender];\n  match sig with\n  | False =>\n    err = NotAlreadySigned;\n    MakeError err\n  | True =>\n    count <- signature_counts[transactionId];\n    match count with\n    | None =>\n      err = IncorrectSignatureCount;\n      MakeError err\n    | Some c =>\n      c_is_zero = builtin eq c zero;\n      match c_is_zero with\n      | True =>\n        err = IncorrectSignatureCount;\n        MakeError err\n      | False =>\n        new_c = builtin sub c one;\n        signature_counts[transactionId] := new_c;\n        delete signatures[transactionId][_sender];\n        e = mk_signature_revoked_event transactionId;\n        event e\n      end\n    end\n  end\nend\n\n(* Delete transaction and signatures *)\nprocedure DeleteTransaction (transactionId : Uint32)\n  delete transactions[transactionId];\n  delete signatures[transactionId];\n  delete signature_counts[transactionId]\nend\n\n(* Execute native token transaction. *)\n(* Checks permission to execute, and checks for sufficient balance. *)\n(* Assumes the transaction has been signed off by enough owners. *)\nprocedure ExecuteNativeTransaction (recipient : ByStr20, amount : Uint128, tag : String)\n  (* Only the recipient or an owner can execute the transaction *)\n  recipient_is_sender = builtin eq recipient _sender;\n  sender_is_owner <- exists owners[_sender];\n  sender_may_execute = orb recipient_is_sender sender_is_owner;\n  match sender_may_execute with\n  | False =>\n    err = SenderMayNotExecute;\n    MakeError err\n  | True =>\n    (* Check for sufficient funds  *)\n    bal <- _balance;\n    not_enough_money = builtin lt bal amount;\n    match not_enough_money with\n    | True =>\n      err = InsufficientFunds;\n      MakeError err\n    | False =>\n      (* Transaction approved, and enough money available. *)\n      (* Execute transaction *)\n      msgs = native_transaction_msg_as_list recipient amount tag;\n      send msgs\n    end\n  end\nend\n\n(* Execute custom transaction. *)\n(* Checks permission to execute. *)\n(* Assumes the transaction has been signed off by enough owners. *)\nprocedure ExecuteCustomTransaction (proxyContract : ByStr20, proxyTransaction : ProxyTransaction)\n  (* Only owners may execute *)\n  sender_is_owner <- exists owners[_sender];\n  match sender_is_owner with\n  | False =>\n    err = SenderMayNotExecute;\n    MakeError err\n  | True =>\n    as_msg = custom_transaction_msg_as_list proxyContract proxyTransaction;\n    send as_msg\n  end\nend\n\n(* Execute signed-off transaction *)\ntransition ExecuteTransaction (transactionId : Uint32)\n  transaction_opt <- transactions[transactionId];\n  match transaction_opt with\n  | None =>\n    (* Transaction was not found. *)\n    err = UnknownTransactionId;\n    MakeError err\n  | Some transaction =>\n    sig_count_opt <- signature_counts[transactionId];\n    match sig_count_opt with\n    | None =>\n      (* Signature count not found, even though the transaction exists.*)\n      err = NoSignatureListFound;\n      MakeError err\n    | Some sig_count =>\n      not_enough_signatures = builtin lt sig_count required_signatures;\n      match not_enough_signatures with\n      | True =>\n        err = NotEnoughSignatures;\n        MakeError err\n      | False =>\n        match transaction with\n        | NativeTransaction recipient amount tag =>\n          ExecuteNativeTransaction recipient amount tag\n        | CustomTransaction proxyContract proxyTransaction =>\n          ExecuteCustomTransaction proxyContract proxyTransaction\n        end;\n        (* Remove transaction and signatures. *)\n        (* Note: The transaction may have failed, but without a callback *)\n        (* we have no way of detecting whether it did *)\n        DeleteTransaction transactionId\n      end\n    end\n  end\nend\n\n(* Add native funds to wallet *)\ntransition AddFunds ()\n  accept\nend",
            "data": "[{\"vname\":\"owners_list\",\"value\":\"[\"0xdFD64AeB30C9025f08C9925E2bD528449b8621b0\",\"0x54fAbc34083Dc0683D16C0d1e2b509d0945c18e2\",\"0xF115F740AC6A123A51eA85811A40Db642cB10529\"]\",\"type\":\"List (ByStr20)\"},{\"vname\":\"required_signatures\",\"value\":\"2\",\"type\":\"Uint32\"},{\"vname\":\"_scilla_version\",\"type\":\"Uint32\",\"value\":\"0\"}]",
            "signature": "a931b32468449283fffb1a570f6900ea548981b9903674bce380f2f4bb6ab9a427f71cea12235f1e25bb61488e17dee15f3979d0f4a737a8dc9591ae12a9a15e",
            "priority": true
        }
    ]
}